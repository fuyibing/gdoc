// author: wsfuyibing <websearch@163.com>
// date: 2022-12-14

// Package reflectors
// convert scanned results into executable script and run it.
package reflectors

import (
	"fmt"
	"github.com/fuyibing/gdoc/base"
	"github.com/fuyibing/gdoc/conf"
	"os"
	"os/exec"
	"sort"
	"strings"
	"sync/atomic"
)

type (
	// Reflection
	// manager reflect result.
	Reflection interface {
		// Clean
		// use to delete all files under docs/.tmp directory.
		Clean()

		// Configure
		// used to build scanned result into docs/.tmp/main.go
		// script file.
		Configure() Reflection

		// Make
		// used to execute /docs/.tmp/main.go and write result to
		// code-name.json, item-name.json.
		Make() error
	}

	mapper struct {
		alias string
		name  string
	}

	reflection struct {
		mapping base.Mapping

		packageIndex  int32
		packageList   []string
		packageMapper map[string]string
		structMapper  map[string]*mapper
	}
)

// New
// return reflection instance.
func New(mapping base.Mapping) Reflection {
	return (&reflection{mapping: mapping}).init()
}

// Clean
// use to delete all files under docs/.tmp directory.
func (o *reflection) Clean() {
	var (
		err  error
		path = fmt.Sprintf("%s%s%s", conf.Path.GetBasePath(), conf.Path.GetDocumentPath(), conf.Path.GetTmpPath())
	)

	conf.Debugger.Info("clean begin: %v", path)

	// Return
	// if read directory error.
	if err = os.RemoveAll(path); err != nil {
		conf.Debugger.Error("clean error: %v", err)
		return
	}

	conf.Debugger.Info("clean finish")
}

// Configure
// used to build scanned result into docs/.tmp/main.go
// script file.
func (o *reflection) Configure() Reflection {
	// Iterate controllers.
	for _, c := range o.mapping.GetControllers() {
		// Iterate methods.
		for _, m := range c.GetMethods() {
			// Request struct.
			if r := m.GetComment().Request; r != nil {
				o.mapper(r.Key, r.Pkg, r.Name)
			}

			// Response struct list.
			for _, r := range m.GetComment().Responses {
				o.mapper(r.Key, r.Pkg, r.Name)
			}
		}
	}

	// Create tmp files.
	o.save()
	return o
}

// Make
// used to execute /docs/.tmp/main.go and write result to
// code-name.json, item-name.json.
func (o *reflection) Make() error {
	// Prepare
	// executable command.
	cmd := exec.Command("go", "run", fmt.Sprintf(
		"%s%s%s/main.go",
		conf.Path.GetBasePath(),
		conf.Path.GetDocumentPath(),
		conf.Path.GetTmpPath(),
	))

	// Block command process
	// until all done.
	buf, err := cmd.Output()

	if err != nil {
		conf.Debugger.Error("make error: %v", err)
	} else {
		conf.Debugger.Info("make done: %s", buf)
	}
	return err
}

// /////////////////////////////////////////////////////////////
// Access and initialize methods
// /////////////////////////////////////////////////////////////

func (o *reflection) init() *reflection {
	o.packageList = make([]string, 0)
	o.packageMapper = make(map[string]string)
	o.structMapper = make(map[string]*mapper)
	return o
}

// Build package, struct
// map with unique.
func (o *reflection) mapper(key, pkg, name string) {
	var (
		alias string
		ok    bool
	)

	// Generate alias.
	if alias, ok = o.packageMapper[pkg]; !ok {
		n := atomic.AddInt32(&o.packageIndex, 1)
		alias = fmt.Sprintf("a%d", n)

		o.packageList = append(o.packageList, pkg)
		o.packageMapper[pkg] = alias
	}

	// Update struct mapper.
	o.structMapper[key] = &mapper{
		alias: alias, name: name,
	}
}

// Build and save
// main script as docs/.tmp/main.go file.
func (o *reflection) save() {
	var (
		path = fmt.Sprintf("%s%s%s/main.go", conf.Path.GetBasePath(), conf.Path.GetDocumentPath(), conf.Path.GetTmpPath())
		text = []string{fmt.Sprintf("// Reflection template."), fmt.Sprintf("// Do not edit this file: %s", o.mapping.GetLastUpdated()), "", "package main"}
	)

	// Package import
	// formatter.
	//
	//   import (
	//       "github.com/fuyibing/gdoc/reflectors"
	//       a1 "sketch/app/logics/user"
	//   )
	sort.Strings(o.packageList)
	text = append(text, "",
		"import (",
		"    \"github.com/fuyibing/gdoc/reflectors\"",
		"",
	)
	for _, k := range o.packageList {
		text = append(text,
			fmt.Sprintf("    %s \"%s\"", o.packageMapper[k], k),
		)
	}
	text = append(text, ")")

	// Main function
	// formatter.
	//
	//   func main() {
	//       ...
	//   }
	text = append(text, "",
		"func main() {",
		"    ref := reflectors.Parser()",
		fmt.Sprintf("    ref.BasePath = \"%s\"", conf.Path.GetBasePath()),
		fmt.Sprintf("    ref.ControllerPath = \"%s\"", conf.Path.GetControllerPath()),
		fmt.Sprintf("    ref.DocumentPath = \"%s\"", conf.Path.GetDocumentPath()),
		fmt.Sprintf("    ref.DocumentJsonFile = \"%s\"", conf.Path.GetDocumentJsonFile()),
		fmt.Sprintf("    ref.TmpPath = \"%s\"", conf.Path.GetTmpPath()),
		"",
		"    for k, p := range map[string]interface{}{",
	)

	// Struct list.
	for k, v := range o.structMapper {
		text = append(text,
			fmt.Sprintf("        \"%s\": &%s.%s{},", k, v.alias, v.name),
		)
	}

	// Call parse and save method.
	text = append(text,
		"    }{",
		"        ref.Parse(k, p)",
		"    }",
		"",
		"    ref.Save()",
		"}",
	)

	// Save file.
	conf.Path.SavePath(path, strings.Join(text, "\n"))
}
