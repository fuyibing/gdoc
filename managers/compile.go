// author: wsfuyibing <websearch@163.com>
// date: 2022-12-11

package managers

import (
	"fmt"
	"github.com/fuyibing/gdoc/config"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"sync/atomic"
)

type (
	Compile interface {
		Configure() error
		Make() error
		Install() error
	}

	compile struct {
		Manager Management

		structPkgIndex int32
		structPkgAlias map[string]string // {"sketch/app/logics/user.LoginRequest":"a1"}
		structPkgList  []string          // {"sketch/app/logics/user.LoginRequest"}
		structMapper   map[string]string // {"sketch/app/logics/user.LoginRequest":"a1.LoginRequest"}
	}
)

// /////////////////////////////////////////////////////////////
// Interface methods
// /////////////////////////////////////////////////////////////

func (o *compile) Configure() error { return o.configure() }
func (o *compile) Make() error      { return o.make() }
func (o *compile) Install() error   { return o.install() }

// /////////////////////////////////////////////////////////////
// Configure defined struct by annotation
// /////////////////////////////////////////////////////////////

func (o *compile) configure() error {
	// Read module name
	// from file.
	mod, err := o.getModule()
	if err != nil {
		return err
	}

	// Iterate scanner results.
	for _, c := range o.Manager.GetScanner().GetControllers() {
		for _, m := range c.GetMethods() {
			if r := m.GetComment().GetRequest(); r != nil {
				o.genStruct(mod, r.GetPackage(), r.GetName())
			}
			for _, r := range m.GetComment().GetResponses() {
				o.genStruct(mod, r.GetPackage(), r.GetName())
			}
		}
	}

	return nil
}

// /////////////////////////////////////////////////////////////
// Install temp file after reflected
// /////////////////////////////////////////////////////////////

func (o *compile) install() error {
	src := fmt.Sprintf("%s%s%s/main.go",
		config.Path.GetBase(),
		config.Path.GetStorage(),
		config.Path.GetTmp(),
	)

	cmd := exec.Command("go", "run", src)

	if err := cmd.Run(); err != nil {
		return err
	}

	return nil
}

// /////////////////////////////////////////////////////////////
// Make main source when configured
// /////////////////////////////////////////////////////////////

func (o *compile) make() error {
	var (
		tpl = fmt.Sprintf(
			"// GDOC Compiled source code\n" +
				"// Do not edit this file.\n" +
				"\n" +
				"package main\n\n",
		)
	)

	// Load imports.
	sort.Strings(o.structPkgList)
	tpl += "import ("
	for _, k := range o.structPkgList {
		tpl += fmt.Sprintf("\n    %s \"%s\"", o.structPkgAlias[k], k)
	}
	tpl += fmt.Sprintf("\n    \"github.com/fuyibing/gdoc/reflectors\"")
	tpl += "\n)\n\n"

	// Load structs.
	tpl += "var mapper = map[string]interface{}{"
	for k, v := range o.structMapper {
		tpl += fmt.Sprintf("\n    \"%s\":&%s{},", k, v)
	}
	tpl += "\n}\n\n"

	// Load main runner.
	tpl += "func main(){\n"
	tpl += "    ref := reflectors.New()\n"
	tpl += "    for k, v := range mapper {\n"
	tpl += "        ref.Parse(k, v)\n"
	tpl += "    }\n"
	tpl += "}\n"

	// Save file.
	src := fmt.Sprintf("%s%s%s/main.go",
		config.Path.GetBase(),
		config.Path.GetStorage(),
		config.Path.GetTmp(),
	)
	if err := o.Manager.SaveFile(src, tpl); err != nil {
		return err
	}

	return nil
}

// /////////////////////////////////////////////////////////////
// Access methods
// /////////////////////////////////////////////////////////////

// Generate struct definition.
//
//   .genStruct("sketch", "app/logics/user", "LoginRequest")
func (o *compile) genStruct(mod, pkg, name string) {
	var (
		alias string
		ok    bool
		key   = fmt.Sprintf("%s/%s", mod, pkg)
	)

	// Generate alias name.
	if alias, ok = o.structPkgAlias[key]; !ok {
		alias = fmt.Sprintf("a%d", atomic.AddInt32(&o.structPkgIndex, 1))
		o.structPkgList = append(o.structPkgList, key)
		o.structPkgAlias[key] = alias
	}

	// Generate mapper.
	o.structMapper[fmt.Sprintf("%s.%s", pkg, name)] = fmt.Sprintf("%s.%s", alias, name)
}

func (o *compile) getModule() (mod string, err error) {
	var (
		buf  []byte
		path = fmt.Sprintf("%s/go.mod", config.Path.GetBase())
	)

	// Read module from go.mod.
	if buf, err = os.ReadFile(path); err != nil {
		return
	}

	// Match regular expression.
	if m := regexp.MustCompile(`\nmodule\s+([^\n]+)`).FindStringSubmatch(fmt.Sprintf("\n%s\n", buf)); len(m) == 2 {
		mod = m[1]
		return
	}

	// Succeed.
	err = fmt.Errorf("parse module error")
	return
}

// /////////////////////////////////////////////////////////////
// Initialize
// /////////////////////////////////////////////////////////////

func (o *compile) init() *compile {
	o.structPkgAlias = make(map[string]string)
	o.structPkgList = make([]string, 0)
	o.structMapper = make(map[string]string)
	return o
}
