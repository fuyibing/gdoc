// author: wsfuyibing <websearch@163.com>
// date: 2022-12-11

package managers

import (
	"fmt"
	"github.com/fuyibing/gdoc/config"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strings"
	"sync/atomic"
)

type (
	Compile interface {
		Configure() error
		Make() error
		Install() error
	}

	compile struct {
		Manager Management

		structPkgIndex int32
		structPkgAlias map[string]string // {"sketch/app/logics/user.LoginRequest":"a1"}
		structPkgList  []string          // {"sketch/app/logics/user.LoginRequest"}
		structMapper   map[string]string // {"sketch/app/logics/user.LoginRequest":"a1.LoginRequest"}
	}
)

// /////////////////////////////////////////////////////////////
// Interface methods
// /////////////////////////////////////////////////////////////

func (o *compile) Configure() error { return o.configure() }
func (o *compile) Make() error      { return o.make() }
func (o *compile) Install() error   { return o.install() }

// /////////////////////////////////////////////////////////////
// Configure defined struct by annotation
// /////////////////////////////////////////////////////////////

func (o *compile) configure() error {
	// Read module name
	// from file.
	mod, err := o.getModule()
	if err != nil {
		return err
	}

	// Iterate scanner results.
	for _, c := range o.Manager.GetScanner().GetControllers() {
		for _, m := range c.GetMethods() {
			if r := m.GetComment().GetRequest(); r != nil {
				o.genStruct(mod, r.GetPackage(), r.GetName())
			}
			for _, r := range m.GetComment().GetResponses() {
				o.genStruct(mod, r.GetPackage(), r.GetName())
			}
		}
	}

	return nil
}

// /////////////////////////////////////////////////////////////
// Install temp file after reflected
// /////////////////////////////////////////////////////////////

func (o *compile) install() error {
	var (
		p  = fmt.Sprintf("%s%s/main.go", config.Path.GetStorage(), config.Path.GetTmp())
		cs = []*exec.Cmd{
			exec.Command("go", "run", strings.TrimPrefix(p, "/")),
		}
	)

	for _, c := range cs {
		o.Manager.GetLogger().Info("[command] %s", c.String())
		buf, err := c.Output()
		if err != nil {
			o.Manager.GetLogger().Info("          error: %s", err)
			return err
		}
		o.Manager.GetLogger().Info("          result: %s", buf)
	}

	return nil
}

func (o *compile) install2() error {
	// src := fmt.Sprintf("%s%s/main.go", config.Path.GetStorage(), config.Path.GetTmp())

	cmd := exec.Command(
		"cd", config.Path.GetBase(), "&&",
		"go", "run", strings.TrimPrefix(
			fmt.Sprintf("%s%s/main.go", config.Path.GetStorage(), config.Path.GetTmp()),
			"/",
		),
	)

	buf, err := cmd.Output()

	if err != nil {
		return err
	}

	println("buffer: ", string(buf))

	// s, _ := bufio.NewReader(c.Stdout).ReadString('\n')
	// println("s: ", s)
	// println("c end: ", c.Stdout())

	return nil
}

// /////////////////////////////////////////////////////////////
// Make main source when configured
// /////////////////////////////////////////////////////////////

func (o *compile) make() error {
	var (
		tpl = fmt.Sprintf(
			"// GDOC Compiled source code\n" +
				"// Do not edit this file.\n" +
				"\n" +
				"package main\n\n",
		)
	)

	// Load imports.
	sort.Strings(o.structPkgList)
	tpl += "import ("
	tpl += fmt.Sprintf("\n    \"github.com/fuyibing/gdoc/reflectors\"")
	for _, k := range o.structPkgList {
		tpl += fmt.Sprintf("\n    %s \"%s\"", o.structPkgAlias[k], k)
	}
	tpl += "\n)\n\n"

	// Load structs.
	tpl += "var mapper = map[string]interface{}{"
	for k, v := range o.structMapper {
		tpl += fmt.Sprintf("\n    \"%s\":&%s{},", k, v)
	}
	tpl += "\n}\n\n"

	// Load main runner.
	tpl += "func main(){\n"
	tpl += "    ref := reflectors.New()\n"
	tpl += fmt.Sprintf("    ref.BasePath = \"%s\"\n", config.Path.GetBase())
	tpl += fmt.Sprintf("    ref.StoragePath = \"%s\"\n", config.Path.GetStorage())
	tpl += fmt.Sprintf("    ref.TmpPath = \"%s\"\n", config.Path.GetTmp())
	tpl += "\n"
	tpl += "    for k, v := range mapper {\n"
	tpl += "        if err := ref.Parse(k, v); err != nil {\n"
	tpl += "        	println(err.Error())\n"
	tpl += "        	return\n"
	tpl += "        }\n"
	tpl += "    }\n"
	tpl += "\n"
	tpl += "    if err := ref.Save(); err != nil {\n"
	tpl += "        println(err.Error())\n"
	tpl += "    }\n"
	tpl += "}\n"

	// Save file.
	src := fmt.Sprintf("%s%s%s/main.go",
		config.Path.GetBase(),
		config.Path.GetStorage(),
		config.Path.GetTmp(),
	)
	if err := o.Manager.SaveFile(src, tpl); err != nil {
		return err
	}

	return nil
}

// /////////////////////////////////////////////////////////////
// Access methods
// /////////////////////////////////////////////////////////////

// Generate struct definition.
//
//   .genStruct("sketch", "app/logics/user", "LoginRequest")
func (o *compile) genStruct(mod, pkg, name string) {
	var (
		alias string
		ok    bool
		key   = fmt.Sprintf("%s/%s", mod, pkg)
	)

	// Generate alias name.
	if alias, ok = o.structPkgAlias[key]; !ok {
		alias = fmt.Sprintf("a%d", atomic.AddInt32(&o.structPkgIndex, 1))
		o.structPkgList = append(o.structPkgList, key)
		o.structPkgAlias[key] = alias
	}

	// Generate mapper.
	o.structMapper[fmt.Sprintf("%s.%s", pkg, name)] = fmt.Sprintf("%s.%s", alias, name)
}

func (o *compile) getModule() (mod string, err error) {
	var (
		buf  []byte
		path = fmt.Sprintf("%s/go.mod", config.Path.GetBase())
	)

	// Read module from go.mod.
	if buf, err = os.ReadFile(path); err != nil {
		return
	}

	// Match regular expression.
	if m := regexp.MustCompile(`\nmodule\s+([^\n]+)`).FindStringSubmatch(fmt.Sprintf("\n%s\n", buf)); len(m) == 2 {
		mod = m[1]
		return
	}

	// Succeed.
	err = fmt.Errorf("parse module error")
	return
}

// /////////////////////////////////////////////////////////////
// Initialize
// /////////////////////////////////////////////////////////////

func (o *compile) init() *compile {
	o.structPkgAlias = make(map[string]string)
	o.structPkgList = make([]string, 0)
	o.structMapper = make(map[string]string)
	return o
}
